# 30-3. Factory Pattern

객체를 만들어 생성자 대신 반환하는 함수를 제공하여 초기화 과정을 외부에서 보지 못하게 숨기고 반환 타입을 제어하는 방법을 `팩토리 패턴(Factor Pattern)`
이라고 한다.

객체지향 프로그래밍에서 `팩토리(Factory)`란 다른 클래스의 객체를 생성하는 클래스를 일컫는다. 일반적으로 팩토리는 객체와 관련 메소드로 구성돼 있다. 
클라이언트는 특정 인자와 함께 메서드를 호출하고 팩토리는 해당 객체를 생성하고 반환한다.

클라이언트가 직접 객체를 생성할 수 있는데 팩토리가 필요한 이유는 다음과 같다.

+ 객체 생성과 클래스 구현을 나눠 상호 의존도를 줄인다.
+ 클라이언트는 생성하려는 객체 클래스 구현과 상관없이 사용할 수 있다. 객체를 생성할 때 필요한 인터페이스와 메서드, 인자 등의 정보만 있으면 된다.
따라서 클라이언트의 일이 줄어든다.
+ 코드를 수정하지 않고 간단하게 팩토리에 새로운 클래스를 추가할 수 있다. 인자 추가가 전부인 경우도 있다.
+ 이미 생성된 객체를 팩토리가 재활용할 수 있다. 클라이언트가 직접 객체를 생성하는 경우 매번 새로운 객체가 생성된다.

자동차나 인형 같은 완구를 제조하는 공장을 예로 들어보자. 이 업체는 자동차 장난감만 제조해왔지만 인형에 대한 시장의 수요가 늘어나는 상황을 고려해 CEO는
급히 인형도 제조하기로 결정했다. 팩토리 패턴이 적합한 상황이다. 이 경우 공장의 제조 기계는 `인터페이스`이고 CEO는 `클라이언트`다. CEO는 제조하려는
`객체(완제품)`와 제품을 만드는 `인터페이스(생산 기계)`에 대해서만 알고 있다.

팩토리 패턴은 다음과 같은 3가지 종류가 있다.

+ __심플 팩토리 패턴(The Simple Factory Pattern)__
  + 인터페이스는 객체 생성 로직을 숨기고, 객체를 생성한다.
+ __팩토리 메서드 패턴(The FActory Method Pattern)__
  + 인터페이스를 통해 객체를 생성하지만 서브 클래스가 객체 생성에 필요한 클래스를 선택한다.
+ __추상 팩토리 패턴(The Abstract Factory Patter)__
  + 객체 생성에 필요한 클래스를 노출하지 않고 객체를 생성하는 인터페이스다. 내부적으로 다른 팩토리 객체를 생성한다.

## 심플 팩토리 패턴 (The Simple Factory Pattern)

심플 팩토리 패턴은 하나의 패턴으로 인정하지 않기도 해서 팩토리 메서드와 추상 팩토리 메서드 패턴을 이해하기 위한 기본 개념 정도로 생각하면 된다.
팩토리를 사용하면 여러 종류의 객체를 사용자가 직접 클래스를 호출하지 않고 생산할 수 있다.

...

```python
class Car:
    def __init__(self): ...
```

```python
class Benz(Car):
    def __init__(self): ...
```

```python
class Porsche(Car):
    def __init__(self): ...
```

예를 들어, 위와 같이 자동차 클래스를 정의했다고 해보자. 이제 자동차들을 도로에 배치해야 하는 상황이다. 그러면 다음과 같이 코드를 구성할 수도 
있다.

```python
class Road:
    def __init__(self, seq_data):
        for dat in seq_data:
            if dat.name == 'Benz':
                return Benz(dat)
            elif dat.name == 'Porsche':
                return Porsche(dat)
            ...
```

작동 자체에는 문제가 없는 코드이지만, 객체지향적으로 보면 [단일 책임 원칙](../../chapter_10/10_7/contents.md)을 위반하였다. `Road`는 말 
그대로 도로 구현 방법에 대해서만 서술되어야 하는데, 데이터를 읽는 부분에서 `유닛`을 `분류`하는 추가적인 `책임`이 포함되어 있다. 만일 새로운 자동차가
생겨나고, 새로운 자동차를 넣어야 한다면 __전혀 상관없는 Road 클래스를 수정해야 할 것이다.__

그래서 다양한 하위 클래스들을 생성하는(Factory: 공장) 클래스를 만들어 그 클래스에 `책임`을 `위임`하는 것이다.   

다음은 팩토리 패턴을 이용한 메서드 정의이다.

```python
class CarFactory:
    @staticmethod
    def create(data):
        if data.name == 'Benz':
            return Benz(data)
        elif data.name == 'Porsche':
            return Porsche(data)
        ...
```

이후 Road 클래스는 다음과 같이 수정하면 된다.

```python
class Road:
    def __init__(self, seq_data):
        for dat in seq_data:
            return CarFactory.create(seq_data.name)
        ...
```

이렇게 한다면, 새로운 자동차가 추가하는지의 여부에 상관없이 다른 클래스를 수정할 필요가 없어져 `단일 책임 원칙`을 잘 지키는 코드가 된다.